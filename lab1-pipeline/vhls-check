#!/usr/bin/env bash
# This script was generated by bashly (https://github.com/DannyBen/bashly)
# Modifying it manually is not recommended

# :command.root_command
root_command() {
  # :src/root_command.sh
  #inspect_args
  
  #set -x
  
  # Get arguments and flags
  source_dir=${args[source_dir]}
  output=${args[--output]}
  work_dir=${args[--work-dir]}
  csim_only=${args[--csim-only]}
  hls_only=${args[--hls-only]}
  cosim_only=${args[--cosim-only]}
  synthesis=${args[--synthesis]}
  verbose=${args[--verbose]}
  docker=${args[--docker]}
  force=${args[--force]}
  log_dir=${args[--log-dir]}
  log_limit=${args[--log-limit]}
  progress=${args[--progress]}
  
  set -ue
  
  source_dir=$(readlink -f $source_dir)
  work_dir=$(readlink -f $work_dir)
  
  self=$(readlink -f $BASH_SOURCE)
  self_base=$(basename $self)
  self_dir=$(dirname $self)
  
  logout=/dev/null
  if [[ $verbose ]] ; then
    logout=/dev/stdout
  fi
  
  # Argument check
  if [[ ! -e $source_dir ]] ; then
    red_bold Error: "Source directory '$source_dir' doesn't exist!"
    exit 1
  fi
  
  if [[ $output ]] ; then
    output=$(readlink -f $output)
    if [[ $force ]] ; then
      echo > $force
    elif [[ -e $output ]] ; then
      red_bold Error: "Output file '$output' already exists!"
      exit 1
    fi
  fi
  
  if [[ $log_dir ]] ; then
    log_dir=$(readlink -f $log_dir)
  fi
  
  if [[ ! $force ]] && [[ -e $work_dir ]] ; then
    red_bold Error: "Working directory '$work_dir' already exists!"
    exit 1
  fi
  
  # Docker
  if [[ $docker ]] ; then
    repo=$self_base
    tag=latest
  
    # Build docker
    #docker build -t $repo:$tag $self_dir
    build_docker_image -t $repo:$tag
  
    # Run docker
    run_opts=
    if [[ $output ]] ; then
      touch $output
      run_opts="$run_opts -v $output:/tmp/output.txt:rw"
    fi
    if [[ $log_dir ]] ; then
      mkdir $log_dir
      run_opts="$run_opts -v $log_dir:/tmp/log:rw"
    fi
  
    cmd_opts=
    if [[ $synthesis ]] ; then
      cmd_opts="$cmd_opts --synthesis"
    fi
    if [[ $log_limit ]] ; then
      cmd_opts="$cmd_opts --log-limit $log_limit"
    fi
    if [[ $progress ]] ; then
      cmd_opts="$cmd_opts --progress"
    fi
  
    docker run \
      --rm \
      -v /tools/Xilinx:/tools/Xilinx:ro \
      -v $self:/tmp/$self_base:ro \
      -v $source_dir:/tmp/source:ro \
      --cpus=1 \
      --memory 16g \
      --env LIBRARY_PATH=/usr/lib/x86_64-linux-gnu \
      $run_opts \
      $repo:$tag \
      /tmp/$self_base --force --output /tmp/output.txt --log-dir /tmp/log $cmd_opts /tmp/source
    
    exit
  fi
  
  # Source files
  regulation=$source_dir/regulation.txt
  tb=$source_dir/tb.cpp
  kernel_source=$source_dir/kernel.cpp
  kernel_header=$source_dir/kernel.hpp
  
  # Argument check
  if [ ! -e $regulation ] ; then
    red_bold "Error: Regulation file ($regulation) doesn't exist!"
    exit 1
  fi
  
  if [ ! -e $tb ] ; then
    red_bold "Error: Testbench ($tb) doesn't exist!"
    exit 1
  fi
  
  if [ ! -e $kernel_source ] ; then
    red_bold "Error: Kernel source ($kernel_source) doesn't exist!"
    exit 1
  fi
  
  if [ ! -e $kernel_header ] ; then
    red_bold "Error: Kernel header ($kernel_header) doesn't exist!"
    exit 1
  fi
  
  # Load regulation
  target_clock_period_ns=10
  flow=vitis
  vitis_version=2021.1
  csim_timeout=1m
  hls_timeout=5m
  cosim_timeout=5m
  syn_timeout=30m
  cxxflags=
  ldflags=
  extra_files=
  
  source $regulation
  
  if [[ $extra_files ]] ; then
    extra_files=$(readlink -f $extra_files)
  fi
  
  # Tool setup
  source /tools/Xilinx/Vitis/$vitis_version/settings64.sh
  # AR# 69355
  if [[ -e /usr/lib/x86_64-linux-gnu ]] ; then
    if [[ -z ${LIBRARY_PATH+x} ]] ; then
      export LIBRARY_PATH=/usr/lib/x86_64-linux-gnu
    else
      export LIBRARY_PATH=/usr/lib/x86_64-linux-gnu:$LIBRARY_PATH
    fi
  fi
  
  # Create working directory
  mkdir -p $work_dir
  
  # Check
  if [[ $csim_only ]] ; then
    check_csim
    exit
  fi
  
  if [[ $hls_only ]] ; then
    check_hls
    exit
  fi
  
  if [[ $cosim_only ]] ; then
    check_hls
    check_cosim
    exit
  fi
  
  check_bytes
  check_csim
  check_hls
  check_cosim
  
  if [[ $synthesis ]] ; then
    check_syn
  fi
  
  get_qor
  get_sim_time
  
  output_summary normal_exit=1
}

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
vhls_check_usage() {
  if [[ -n $long_usage ]]; then
    printf "vhls-check - Vitis HLS checker\n"
    echo 
  else
    printf "vhls-check - Vitis HLS checker\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  vhls-check [SOURCE_DIR] [options]\n"
  printf "  vhls-check --help | -h\n"
  printf "  vhls-check --version\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version"
    printf "    Show version number\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --output, -o OUTPUT"
    printf "    Output summary to the specified file\n"
    echo
    
    # :flag.usage
    echo "  --work-dir, -w WORK_DIR"
    printf "    Working directory\n"
    printf "    Default: ./work\n"
    echo
    
    # :flag.usage
    echo "  --csim-only"
    printf "    Run csim\n"
    echo
    
    # :flag.usage
    echo "  --hls-only"
    printf "    Run hls\n"
    echo
    
    # :flag.usage
    echo "  --cosim-only"
    printf "    Run hls and cosim\n"
    echo
    
    # :flag.usage
    echo "  --synthesis, -s"
    printf "    Run synthesis for resource/timing estimation\n"
    echo
    
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Verbose log output\n"
    echo
    
    # :flag.usage
    echo "  --docker, -d"
    printf "    Run in docker container environment\n"
    echo
    
    # :flag.usage
    echo "  --force, -f"
    printf "    Force output even if files or directories already exist\n"
    echo
    
    # :flag.usage
    echo "  --log-dir, -l LOG_DIR"
    printf "    Log output directory\n"
    echo
    
    # :flag.usage
    echo "  --log-limit LOG_LIMIT"
    printf "    Limit log output in bytes\n"
    echo
    
    # :flag.usage
    echo "  --progress"
    printf "    Show progress\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  SOURCE_DIR"
    printf "    Target source directory\n"
    printf "    Default: ./\n"
    echo

  fi
}

# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi
}

# :command.user_lib
# :src/lib/utils.sh
output_summary() {
  if [[ $output ]] ; then
    echo "$*" >> $output
  fi
}

copy_log() {
  if [[ $log_dir ]] ; then
    if [[ $log_limit ]] ; then
      head -c $log_limit "$1" > $log_dir/$(basename "$1")
    else
      cp "$1" $log_dir/$(basename "$1")
    fi
  fi
}

bold_nnl() { printf "\e[1m%b\e[0m" "$*"; }

print_result() {
  bold_nnl "$1"; shift
  echo "$*"
}

print_pass() {
  bold_nnl "$1"; shift
  green "$*"
}

print_fail() {
  bold_nnl "$1"; shift
  red "$*"
}

print_progress() {
  if [[ $progress ]] ; then
    echo testing_$1
  fi
}

check_bytes() {
  local bytes
  bytes=$(cat $kernel_header $kernel_source | wc -c  | awk '{print $1}')
  output_summary bytes=$bytes
  print_result "Bytes of kernel code: " $bytes
}

# :src/lib/colors.sh
# ---
# Color functions
# This file is a part of Bashly standard library
#
# Usage:
# Use any of the functions below to color or format a portion of a string.
# 
#   echo "before $(red this is red) after"
#   echo "before $(green_bold this is green_bold) after"
#
# ---

red() { printf "\e[31m%b\e[0m\n" "$*"; }
green() { printf "\e[32m%b\e[0m\n" "$*"; }
yellow() { printf "\e[33m%b\e[0m\n" "$*"; }
blue() { printf "\e[34m%b\e[0m\n" "$*"; }
magenta() { printf "\e[35m%b\e[0m\n" "$*"; }
cyan() { printf "\e[36m%b\e[0m\n" "$*"; }
bold() { printf "\e[1m%b\e[0m\n" "$*"; }
underlined() { printf "\e[4m%b\e[0m\n" "$*"; }
red_bold() { printf "\e[1;31m%b\e[0m\n" "$*"; }
green_bold() { printf "\e[1;32m%b\e[0m\n" "$*"; }
yellow_bold() { printf "\e[1;33m%b\e[0m\n" "$*"; }
blue_bold() { printf "\e[1;34m%b\e[0m\n" "$*"; }
magenta_bold() { printf "\e[1;35m%b\e[0m\n" "$*"; }
cyan_bold() { printf "\e[1;36m%b\e[0m\n" "$*"; }
red_underlined() { printf "\e[4;31m%b\e[0m\n" "$*"; }
green_underlined() { printf "\e[4;32m%b\e[0m\n" "$*"; }
yellow_underlined() { printf "\e[4;33m%b\e[0m\n" "$*"; }
blue_underlined() { printf "\e[4;34m%b\e[0m\n" "$*"; }
magenta_underlined() { printf "\e[4;35m%b\e[0m\n" "$*"; }
cyan_underlined() { printf "\e[4;36m%b\e[0m\n" "$*"; }

# :src/lib/docker.sh
build_docker_image() {
  local dockerfile=$(mktemp)
  cat << 'EOS' > $dockerfile
FROM ubuntu:18.04

SHELL ["/bin/bash", "-c"]

ENV DEBIAN_FRONTEND=noninteractive

# Timezone
ENV TZ=Asia/Tokyo
RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone

# Install packages
RUN apt-get update -y && apt-get install -y \
      build-essential \
      bzip2 \
      libc6-i386 \
      libc6-dev-i386 \
      gcc-multilib \
      g++-multilib \
      git \
      libfontconfig1 \
      libglib2.0-0 \
      sudo \
      nano \
      locales \
      libxext6 \
      libxrender1 \
      libxtst6 \
      libgtk2.0-0 \
      build-essential \
      unzip \
      ruby \
      ruby-dev \
      pkg-config \
      libprotobuf-dev \
      protobuf-compiler \
      python-protobuf \
      python-pip \
      bc \
      time \
      libboost-dev \
      && apt autoclean -y \
      && apt autoremove -y \
      && rm -rf /var/lib/apt/lists/*

# Locale
RUN locale-gen en_US.UTF-8
EOS

  docker build $* -f $dockerfile .
  rm $dockerfile
}

# :src/lib/get_result.sh
######################################
# Get QoR
######################################
get_qor() {

  if [[ $synthesis ]] ; then

    local report_xml=$work_dir/prj_hls_cosim/solution/impl/report/verilog/kernel_export.xml
    if [[ $vitis_version == "2021.1" ]] ; then
      report_xml=$work_dir/prj_hls_cosim/solution/impl/report/verilog/export_syn.xml
    fi

    # Get resource/timing estimation from synthesis report
    ruby << EOS >> $work_dir/qor.txt
require 'rexml/document'

doc = REXML::Document.new(File.new("$report_xml"))

puts "ff=#{doc.elements['profile/AreaReport/Resources/FF'].text}"
puts "lut=#{doc.elements['profile/AreaReport/Resources/LUT'].text}"
puts "dsp=#{doc.elements['profile/AreaReport/Resources/DSP'].text}"
puts "bram=#{doc.elements['profile/AreaReport/Resources/BRAM'].text}"
puts "uram=#{doc.elements['profile/AreaReport/Resources/URAM'].text}"
puts "clock_period=#{doc.elements['profile/TimingReport/AchievedClockPeriod'].text}"
EOS

  else
    # Get resource/timing estimation from hls report
    ruby << EOS >> $work_dir/qor.txt
require 'rexml/document'

doc = REXML::Document.new(File.new("$work_dir/prj_hls_cosim/solution/syn/report/csynth.xml"))

puts "ff=#{doc.elements['profile/AreaEstimates/Resources/FF'].text}"
puts "lut=#{doc.elements['profile/AreaEstimates/Resources/LUT'].text}"
puts "dsp=#{doc.elements['profile/AreaEstimates/Resources/DSP'].text}"
puts "bram=#{doc.elements['profile/AreaEstimates/Resources/BRAM_18K'].text}"
puts "uram=#{doc.elements['profile/AreaEstimates/Resources/URAM'].text}"
puts "clock_period=#{doc.elements['profile/PerformanceEstimates/SummaryOfTimingAnalysis/EstimatedClockPeriod'].text}"
EOS

  fi

  #eval $(grep clock_period $work_dir/qor.txt)
  eval $(cat $work_dir/qor.txt)

  if [[ $output ]] ; then
    cat $work_dir/qor.txt >> $output
  fi

  print_result "Resource usage"
  print_result "  FF   : " $ff
  print_result "  LUT  : " $lut
  print_result "  DSP  : " $dsp
  print_result "  BRAM : " $bram
  print_result "  URAM : " $uram
  print_result "Clock period (ns): " $clock_period
  print_result "Clock frequency (MHz): " $(echo "1000/$clock_period" | bc)
}

######################################
# Get simulation time
get_sim_time() {
  #sim_start=$(grep -e '^// RTL Simulation .* \[0\.00%\]' $work_dir/vitis_hls.log | awk -F @ '{print $2}' | sed 's/[^0-9]//g')
  #sim_end=$(grep -e '^// RTL Simulation .* \[100\.00%\]' $work_dir/vitis_hls.log | awk -F @ '{print $2}' | sed 's/[^0-9]//g')
  local sim_start=$(grep --text -e '^// RTL Simulation .* @ "[0-9]*"' $work_dir/cosim.log | head -n 1 | awk -F @ '{print $2}' | sed 's/[^0-9]//g')
  local sim_end=$(grep --text -e '^// RTL Simulation .* @ "[0-9]*"' $work_dir/cosim.log | tail -n 1 | awk -F @ '{print $2}' | sed 's/[^0-9]//g')
  
  local sim_time=$(echo "($sim_end-$sim_start)/1000" | bc)
  local sim_cycle=$(echo $sim_time/$target_clock_period_ns | bc)
  local sim_time=$(echo $sim_cycle*$clock_period | bc)
  
  output_summary sim_cycle=$sim_cycle
  output_summary sim_time=$sim_time

  print_result "Simulation cycle: " $sim_cycle
  print_result "Simulation time (ns): " $sim_time
}

# :src/lib/csim_checker.sh
######################################
# Check csim
######################################

check_csim() {
  print_progress csim

  pushd $work_dir > /dev/null

  local csim_cxxflags="$cxxflags -I$source_dir"
  local csim_result=
  local csim_fail=1
  local csim_timeout_error=0
  local csim_compile_error=0
  local csim_runtime_error=0
  local csim_error=0
  local csim_mismatch=0
  
  cat << EOS > csim.tcl
open_project -reset prj_csim
add_files -cflags "$csim_cxxflags" $kernel_source
add_files -cflags "$csim_cxxflags -DCSIM" -tb $tb
EOS
  
  if [[ $extra_files ]] ; then
    echo "add_files \"$extra_files\"" >> csim.tcl
  fi

  cat << EOS >> csim.tcl
set_top kernel
open_solution -flow_target $flow solution
set_part xcu200-fsgd2104-2-e
create_clock -period ${target_clock_period_ns}ns -name default
csim_design -ldflags "$ldflags"
exit
EOS
  
  set +e
  timeout $csim_timeout time vitis_hls -f csim.tcl |& tee csim.log > $logout
  local exit_code=${PIPESTATUS[0]}
  set -e
  
  if [ $exit_code -eq 124 ] ; then
    csim_timeout_error=1
    csim_result="Timeout ($csim_timeout)"
  elif grep --text -e "^ERROR:" $work_dir/vitis_hls.log | grep "compilation error" > /dev/null ; then
    csim_compile_error=1
    csim_result="Compile error, see log file: $work_dir/csim.log"
  elif grep --text -e "^ERROR:" $work_dir/vitis_hls.log | grep "CSim failed with errors" > /dev/null ; then
    csim_runtime_error=1
    csim_result="Runtime error, see log file: $work_dir/csim.log"
  elif grep --text -e "^ERROR:" $work_dir/vitis_hls.log | grep "nonzero return value" > /dev/null ; then
    csim_mismatch=1
    csim_result="Mismatch"
  elif [ $exit_code -ne 0 ] ; then
    csim_error=1
    csim_result="Unknown error (exit code: $exit_code), see log file: $work_dir/csim.log"
  else
    csim_fail=0
    csim_result="Pass"
  fi
  
  output_summary csim_fail=$csim_fail
  output_summary csim_timeout=$csim_timeout_error
  output_summary csim_compile_error=$csim_compile_error
  output_summary csim_runtime_error=$csim_runtime_error
  output_summary csim_error=$csim_error
  output_summary csim_mismatch=$csim_mismatch

  copy_log csim.log
  
  if [ $csim_fail -ne 0 ] ; then
    print_fail "CSim: " $csim_result
    exit
  else
    print_pass "CSim: " $csim_result
  fi
  
  popd > /dev/null
}

# :src/lib/syn_checker.sh
######################################
# Check syn
######################################

check_syn() {
  print_progress syn

  pushd $work_dir > /dev/null
  
  local syn_fail=1
  local syn_timeout_error=0
  
  cat << EOS > syn.tcl
open_project prj_hls_cosim
open_solution -flow_target $flow solution
export_design -flow syn -rtl verilog -format ip_catalog
exit
EOS
  
  set +e
  timeout $syn_timeout time vitis_hls -f syn.tcl |& tee syn.log > $logout
  exit_code=${PIPESTATUS[0]}
  set -e
  
  if [ $exit_code -eq 124 ] ; then
    syn_timeout_error=1
    syn_result="Timeout ($syn_timeout)"
  else
    syn_fail=0
    syn_result=Pass
  fi
  
  output_summary syn_fail=$syn_fail
  output_summary syn_timeout=$syn_timeout_error

  #copy_log syn.log
  
  if [ $syn_fail -ne 0 ] ; then
    print_fail "Syn: " $syn_result
    exit
  else
    print_pass "Syn: " $syn_result
  fi
  
  popd > /dev/null
}

# :src/lib/cosim_checker.sh
######################################
# Check cosim
######################################

check_cosim() {
  print_progress cosim

  pushd $work_dir > /dev/null
  
  local cosim_cxxflags="$cxxflags -I$source_dir"
  local cosim_result=
  local cosim_fail=1
  local cosim_timeout_error=0
  local cosim_error=0
  local cosim_mismatch=0
  
  cat << EOS > cosim.tcl
open_project prj_hls_cosim
add_files -cflags "$cosim_cxxflags -DCOSIM" -tb $tb
EOS
  
  if [[ $extra_files ]] ; then
    echo "add_files \"$extra_files\"" >> cosim.tcl
  fi

  cat << EOS >> cosim.tcl
open_solution -flow_target $flow solution
cosim_design -ldflags "$ldflags"
exit
EOS

  set +e
  timeout $cosim_timeout time vitis_hls -f cosim.tcl |& tee cosim.log > $logout
  exit_code=${PIPESTATUS[0]}
  set -e
  
  if [ $exit_code -eq 124 ] ; then
    cosim_timeout_error=1
    cosim_result="Timeout ($cosim_timeout)"
  elif grep --text -e "^ERROR:" $work_dir/vitis_hls.log | grep "nonzero return value" > /dev/null ; then
    cosim_mismatch=1
    cosim_result="Mismatch"
  elif grep --text -e "^ERROR:" $work_dir/vitis_hls.log > /dev/null ; then
    cosim_error=1
    cosim_result="Error, see log file: $work_dir/cosim.log"
  elif [ $exit_code -ne 0 ] ; then
    cosim_error=1
    cosim_result="Unknown error, see log file: $work_dir/cosim.log"
  else
    cosim_fail=0
    cosim_result="Pass"
  fi
  
  output_summary cosim_fail=$cosim_fail
  output_summary cosim_timeout=$cosim_timeout_error
  output_summary cosim_error=$cosim_error
  output_summary cosim_mismatch=$cosim_mismatch

  copy_log cosim.log
  
  if [ $cosim_fail -ne 0 ] ; then
    print_fail "CoSim: " $cosim_result
    exit
  else
    print_pass "CoSim: " $cosim_result
  fi
  
  popd > /dev/null
}

# :src/lib/hls_checker.sh
######################################
# Check hls
######################################

check_hls() {
  print_progress hls

  pushd $work_dir > /dev/null
  
  local hls_cxxflags="$cxxflags -I$source_dir"
  local hls_result=
  local hls_fail=1
  local hls_timeout_error=0
  local hls_error=0
  
  cat << EOS > hls.tcl
open_project -reset prj_hls_cosim
add_files -cflags "$hls_cxxflags" $kernel_source
set_top kernel
open_solution -flow_target $flow solution
set_part xcu200-fsgd2104-2-e
create_clock -period ${target_clock_period_ns}ns -name default
csynth_design
exit
EOS
  
  set +e
  timeout $hls_timeout time vitis_hls -f hls.tcl |& tee hls.log > $logout
  exit_code=${PIPESTATUS[0]}
  set -e
  
  if [ $exit_code -eq 124 ] ; then
    hls_timeout_error=1
    hls_result="Timeout ($hls_timeout)"
  elif grep --text -e "^ERROR:" $work_dir/vitis_hls.log > /dev/null ; then
    hls_error=1
    hls_result="HLS error, see log file: $work_dir/hls.log"
  elif [ $exit_code -ne 0 ] ; then
    hls_error=1
    hls_result="HLS unknown error, see log file: $work_dir/hls.log"
  elif [ ! -e $work_dir/prj_hls_cosim/solution/syn/report/csynth.xml ] ; then
    hls_error=1
    hls_result="HLS report not found, see log file: $work_dir/hls.log"
  else
    hls_fail=0
    hls_result=Pass
  fi
  
  output_summary hls_fail=$hls_fail
  output_summary hls_timeout=$hls_timeout_error
  output_summary hls_error=$hls_error

  copy_log hls.log
  
  if [ $hls_fail -ne 0 ] ; then
    print_fail "HLS: " $hls_result
    exit
  else
    print_pass "HLS: " $hls_result
  fi
  
  popd > /dev/null
}

# :command.command_functions

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    vhls_check_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="root"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --output | -o )
      if [[ $2 ]]; then
        args[--output]="$2"
        shift
        shift
      else
        printf "%s\n" "--output requires an argument: --output, -o OUTPUT"
        exit 1
      fi
      ;;
  
    # :flag.case
    --work-dir | -w )
      if [[ $2 ]]; then
        args[--work-dir]="$2"
        shift
        shift
      else
        printf "%s\n" "--work-dir requires an argument: --work-dir, -w WORK_DIR"
        exit 1
      fi
      ;;
  
    # :flag.case
    --csim-only )
      args[--csim-only]=1
      shift
      ;;
  
    # :flag.case
    --hls-only )
      args[--hls-only]=1
      shift
      ;;
  
    # :flag.case
    --cosim-only )
      args[--cosim-only]=1
      shift
      ;;
  
    # :flag.case
    --synthesis | -s )
      args[--synthesis]=1
      shift
      ;;
  
    # :flag.case
    --verbose | -v )
      args[--verbose]=1
      shift
      ;;
  
    # :flag.case
    --docker | -d )
      args[--docker]=1
      shift
      ;;
  
    # :flag.case
    --force | -f )
      args[--force]=1
      shift
      ;;
  
    # :flag.case
    --log-dir | -l )
      if [[ $2 ]]; then
        args[--log-dir]="$2"
        shift
        shift
      else
        printf "%s\n" "--log-dir requires an argument: --log-dir, -l LOG_DIR"
        exit 1
      fi
      ;;
  
    # :flag.case
    --log-limit )
      if [[ $2 ]]; then
        args[--log-limit]="$2"
        shift
        shift
      else
        printf "%s\n" "--log-limit requires an argument: --log-limit LOG_LIMIT"
        exit 1
      fi
      ;;
  
    # :flag.case
    --progress )
      args[--progress]=1
      shift
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[source_dir]} ]]; then
        args[source_dir]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.default_assignments
  [[ -n ${args[source_dir]} ]] || args[source_dir]="./"
  [[ -n ${args[--work-dir]} ]] || args[--work-dir]="./work"
}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e  

  # :src/initialize.sh
  # Code here runs inside the initialize() function
  # Use it for anything that you need to run before any other function, like
  # setting environment vairables:
  # CONFIG_FILE=settings.ini
  #
  # Feel free to empty (but not delete) this file.
}

# :command.run
run() {
  declare -A args
  parse_requirements "$@"

  if [[ ${args[--version]} ]]; then
    version_command
  elif [[ ${args[--help]} ]]; then
    long_usage=yes
    vhls-check_usage
  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
